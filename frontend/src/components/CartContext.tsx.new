import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react'
import { api, type Product, type CartItem } from '../utils/api'
import { useAuth } from './AuthContext'

// Type for guest cart items stored in localStorage
type GuestCartItem = {
  productId: number;
  quantity: number;
  product: Product;
}

type CartContextValue = {
  items: CartItem[]
  add: (product: Product, qty?: number) => void
  addToCart: (productId: number, quantity: number) => Promise<boolean>
  remove: (id: string) => void
  removeFromCart: (itemId: number) => Promise<boolean>
  setQty: (id: string, qty: number) => void
  updateQuantity: (itemId: number, quantity: number) => Promise<boolean>
  clear: () => void
  loading: boolean
  syncWithBackend: () => Promise<void>
  getCartTotal: () => number
  getCartItemsCount: () => number
}

const GUEST_CART_KEY = 'phone_store_guest_cart';

const CartContext = createContext<CartContextValue | null>(null)

export function CartProvider({ children }: { children: React.ReactNode }) {
  const { user } = useAuth()
  const [items, setItems] = useState<CartItem[]>([])
  const [loading, setLoading] = useState(false)
  
  // Load the guest cart from localStorage
  const loadGuestCart = useCallback(() => {
    try {
      const storedCart = localStorage.getItem(GUEST_CART_KEY);
      if (storedCart) {
        const guestCartItems = JSON.parse(storedCart) as GuestCartItem[];
        
        // Convert guest cart items to CartItem format
        const cartItems: CartItem[] = guestCartItems.map(item => ({
          id: item.productId, // Use productId as cart item id for guest cart
          quantity: item.quantity,
          Product: item.product
        }));
        
        setItems(cartItems);
      }
    } catch (error) {
      console.error('Failed to load guest cart:', error);
      // Clear corrupted cart data
      localStorage.removeItem(GUEST_CART_KEY);
      setItems([]);
    }
  }, []);
  
  // Save the guest cart to localStorage
  const saveGuestCart = useCallback((cartItems: CartItem[]) => {
    try {
      // Convert CartItem[] to GuestCartItem[] format
      const guestCartItems: GuestCartItem[] = cartItems.map(item => {
        // Safely convert product ID to number
        let productId: number;
        if (typeof item.Product.id === 'number') {
          productId = item.Product.id;
        } else if (typeof item.Product.id === 'string') {
          productId = parseInt(item.Product.id);
          if (isNaN(productId)) productId = 0;
        } else {
          productId = 0;
        }
        
        return {
          productId,
          quantity: item.quantity,
          product: item.Product
        };
      });
      
      localStorage.setItem(GUEST_CART_KEY, JSON.stringify(guestCartItems));
    } catch (error) {
      console.error('Failed to save guest cart:', error);
    }
  }, []);

  // Helper function to update guest cart
  const updateGuestCart = useCallback((productId: string | number, quantity: number) => {
    const idStr = String(productId);
    
    if (quantity <= 0) {
      // Remove item from cart
      const updatedItems = items.filter(item => String(item.Product.id) !== idStr);
      setItems(updatedItems);
      saveGuestCart(updatedItems);
    } else {
      // Update quantity
      const updatedItems = items.map(item => {
        if (String(item.Product.id) === idStr) {
          return { ...item, quantity };
        }
        return item;
      });
      setItems(updatedItems);
      saveGuestCart(updatedItems);
    }
  }, [items, saveGuestCart]);
  
  // Helper to add product to guest cart
  const addProductToGuestCart = useCallback((product: Product, quantity: number) => {
    const productIdStr = String(product.id);
    const existingItemIndex = items.findIndex(item => 
      String(item.Product.id) === productIdStr
    );
    
    if (existingItemIndex >= 0) {
      // Product already in cart, update quantity
      const updatedItems = [...items];
      updatedItems[existingItemIndex].quantity += quantity;
      setItems(updatedItems);
      saveGuestCart(updatedItems);
    } else {
      // Product not in cart, add it
      let numericId = 0;
      if (typeof product.id === 'number') {
        numericId = product.id;
      } else if (typeof product.id === 'string') {
        numericId = parseInt(product.id);
        if (isNaN(numericId)) numericId = 0;
      }
      
      const newItem: CartItem = {
        id: numericId,
        quantity,
        Product: product
      };
      const updatedItems = [...items, newItem];
      setItems(updatedItems);
      saveGuestCart(updatedItems);
    }
    return true;
  }, [items, saveGuestCart]);

  // Sync cart with backend for logged-in users
  const syncWithBackend = useCallback(async () => {
    if (!user) {
      loadGuestCart();
      return;
    }
    
    setLoading(true);
    try {
      const response = await api.getCart();
      if (response.success && response.data) {
        setItems(response.data.items || []);
      }
    } catch (error) {
      console.error('Failed to sync cart with backend:', error);
    } finally {
      setLoading(false);
    }
  }, [user, loadGuestCart]);

  // Remove item from cart
  const removeFromCart = useCallback(async (itemId: number): Promise<boolean> => {
    try {
      if (user) {
        // User is logged in, use backend cart
        const response = await api.removeFromCart(itemId);
        if (response.success) {
          await syncWithBackend();
          return true;
        }
        return false;
      } else {
        // User is not logged in, remove from guest cart
        const itemToRemove = items.find(item => item.id === itemId);
        if (itemToRemove) {
          updateGuestCart(itemToRemove.Product.id, 0);
          return true;
        }
        return false;
      }
    } catch (error) {
      console.error('Failed to remove from cart:', error);
      return false;
    }
  }, [user, syncWithBackend, items, updateGuestCart]);

  // Update quantity of item in cart
  const updateQuantity = useCallback(async (itemId: number, quantity: number): Promise<boolean> => {
    try {
      if (user) {
        // User is logged in, use backend cart
        const response = await api.updateCartItem(itemId, quantity);
        if (response.success) {
          await syncWithBackend();
          return true;
        }
        return false;
      } else {
        // User is not logged in, update guest cart
        const itemToUpdate = items.find(item => item.id === itemId);
        if (itemToUpdate) {
          updateGuestCart(itemToUpdate.Product.id, quantity);
          return true;
        }
        return false;
      }
    } catch (error) {
      console.error('Failed to update cart quantity:', error);
      return false;
    }
  }, [user, syncWithBackend, items, updateGuestCart]);
  
  // API-style add to cart (returns promise)
  const addToCart = useCallback(async (productId: number, quantity: number): Promise<boolean> => {
    try {
      if (user) {
        // User is logged in, use backend cart
        const response = await api.addToCart(productId, quantity);
        if (response.success) {
          await syncWithBackend();
          return true;
        }
        return false;
      } else {
        // User is not logged in, get product details and add to guest cart
        const productResponse = await api.getProduct(productId);
        if (productResponse.success && productResponse.data) {
          const product = productResponse.data.product;
          return addProductToGuestCart(product, quantity);
        }
        return false;
      }
    } catch (error) {
      console.error('Failed to add to cart:', error);
      return false;
    }
  }, [user, syncWithBackend, addProductToGuestCart]);

  // Add to cart (simple version for use in components)
  const add = useCallback((product: Product, qty = 1) => {
    if (!product) return;
    
    if (user) {
      // Call the function implementation directly
      addToCart(
        typeof product.id === 'number' 
          ? product.id 
          : typeof product.id === 'string'
            ? parseInt(product.id)
            : 0, 
        qty
      );
    } else {
      addProductToGuestCart(product, qty);
    }
  }, [user, addToCart, addProductToGuestCart]);

  // Set quantity of item in cart
  const setQty = useCallback((id: string, qty: number) => {
    if (user) {
      // Find the cart item with the matching ID
      const backendItem = items.find(item => {
        // Check both item.id and item.Product.id for flexibility
        return String(item.id) === id || String(item.Product.id) === id;
      });
      
      if (backendItem) {
        if (qty <= 0) {
          removeFromCart(backendItem.id);
        } else {
          updateQuantity(backendItem.id, qty);
        }
      }
    } else {
      // Guest user
      updateGuestCart(id, qty);
    }
  }, [user, items, removeFromCart, updateQuantity, updateGuestCart]);

  // Remove item from cart (shorthand for setQty with 0)
  const remove = useCallback((id: string) => setQty(id, 0), [setQty]);
  
  // Clear entire cart
  const clear = useCallback(async () => {
    if (user) {
      // User is logged in, clear backend cart
      try {
        if (items && items.length > 0) {
          await Promise.all(
            items.map((item) => api.removeFromCart(item.id))
          );
        }
        await syncWithBackend();
      } catch (error) {
        console.error('Failed to clear backend cart:', error);
      }
    } else {
      // User is not logged in, clear guest cart
      setItems([]);
      localStorage.removeItem(GUEST_CART_KEY);
    }
  }, [user, items, syncWithBackend]);

  // Get total price of cart
  const getCartTotal = useCallback((): number => {
    if (!items || items.length === 0) return 0;
    return items.reduce((total, item) => {
      return total + (item.Product.price * item.quantity);
    }, 0);
  }, [items]);

  // Get total number of items in cart
  const getCartItemsCount = useCallback((): number => {
    if (!items || items.length === 0) return 0;
    return items.reduce((total, item) => {
      return total + item.quantity;
    }, 0);
  }, [items]);

  // Load initial cart when component mounts or user changes
  useEffect(() => {
    if (user) {
      // User is logged in, get cart from backend
      syncWithBackend();
    } else {
      // User is not logged in, load guest cart from localStorage
      loadGuestCart();
    }
  }, [user, syncWithBackend, loadGuestCart]);

  // Create value object with all cart functions
  const value = useMemo<CartContextValue>(() => ({ 
    items, 
    add, 
    addToCart,
    remove, 
    removeFromCart,
    setQty, 
    updateQuantity,
    clear, 
    loading,
    syncWithBackend,
    getCartTotal,
    getCartItemsCount
  }), [items, add, addToCart, remove, removeFromCart, setQty, updateQuantity, clear, loading, syncWithBackend, getCartTotal, getCartItemsCount]);

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}

export function useCart(): CartContextValue {
  const ctx = useContext(CartContext);
  if (!ctx) throw new Error('useCart must be used within <CartProvider>');
  return ctx;
}

export default CartProvider;
