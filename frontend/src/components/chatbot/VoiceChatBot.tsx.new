import React, { useState, useRef, useEffect } from "react";
import ShoppingPanel from "./components/ShoppingPanel";
import VoiceSettingsPanel from "./components/VoiceSettingsPanel";
import ConversationHistory from "./components/ConversationHistory";
import type { Message, ConversationHistoryItem, ToolCall } from "./types/chatTypes";
import { HISTORY_STORAGE_KEY, VOICE_SETTINGS_KEY, generateId, checkForNonEcomProducts, convertToLegacyMessageFormat } from "./utils/chatUtils";
import { analyzeUserMessage, updateStateFromAssistantMessage } from "./utils/messageAnalysis";
import { useSpeechRecognition } from "./hooks/useSpeechRecognition";
import { useSpeechSynthesis } from "./hooks/useSpeechSynthesis";
import { useShopping } from "./hooks/useShopping";
import VoiceVisualizer, { getVisualizerData } from "./components/VoiceVisualizer";
import { useCart } from "../CartContext.js";
import { api } from "../../utils/api.js";
import './chatStyles.css';
import './voiceChatStyles.css';
import './voiceEnhancements.css';

// This is the improved, shorter version of VoiceChatBot component
const VoiceChatBot: React.FC = () => {
  // Core state
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [isOpen, setIsOpen] = useState(false);
  
  // UI state
  const [showSettings, setShowSettings] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [showBrowserNotice, setShowBrowserNotice] = useState(false);
  const [continuousListening, setContinuousListening] = useState(false);
  
  // History state
  const [conversationHistory, setConversationHistory] = useState<ConversationHistoryItem[]>([]);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  
  // Refs
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Get cart functionality 
  const cartFunctions = useCart();

  // Initialize shopping state
  const shopping = useShopping({ useCart: () => cartFunctions });
  
  // Initialize speech synthesis
  const speech = useSpeechSynthesis({ isCheckoutMode: shopping.isCheckoutMode });
  
  // Initialize speech recognition
  const recognition = useSpeechRecognition({
    continuousListening,
    isSpeaking: speech.isSpeaking,
    isCheckoutMode: shopping.isCheckoutMode,
    onResult: (text) => {
      setInput(text);
      sendMessage(text);
    }
  });
  
  // Show browser compatibility warning if speech isn't fully supported
  useEffect(() => {
    if (recognition.browserCompatWarning) {
      setShowBrowserNotice(true);
    }
  }, [recognition.browserCompatWarning]);
  
  // Load conversation history from local storage
  useEffect(() => {
    try {
      const savedHistory = localStorage.getItem(HISTORY_STORAGE_KEY);
      if (savedHistory) {
        const parsedHistory = JSON.parse(savedHistory);
        const processedHistory = parsedHistory.map((conversation: any) => ({
          ...conversation,
          timestamp: new Date(conversation.timestamp),
          messages: conversation.messages.map((msg: any) => ({
            ...msg,
            timestamp: new Date(msg.timestamp)
          }))
        }));
        setConversationHistory(processedHistory);
      }
    } catch (error) {
      console.error('Failed to load conversation history:', error);
    }
  }, []);
  
  // Load voice settings from local storage
  useEffect(() => {
    try {
      const savedSettings = localStorage.getItem(VOICE_SETTINGS_KEY);
      if (savedSettings) {
        const { rate, pitch, volume, continuousMode } = JSON.parse(savedSettings);
        speech.setVoiceRate(rate || 1.0);
        speech.setVoicePitch(pitch || 1.0);
        speech.setVoiceVolume(volume || 1.0);
        setContinuousListening(continuousMode || false);
      }
    } catch (error) {
      console.error('Failed to load voice settings:', error);
    }
  }, []);
  
  // Auto-scroll to the latest message
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // Focus input when chat opens
  useEffect(() => {
    if (isOpen) {
      inputRef.current?.focus();
    }
  }, [isOpen]);
  
  // Save voice settings when they change
  useEffect(() => {
    try {
      localStorage.setItem(VOICE_SETTINGS_KEY, JSON.stringify({
        rate: speech.voiceRate,
        pitch: speech.voicePitch,
        volume: speech.voiceVolume,
        continuousMode: continuousListening
      }));
    } catch (error) {
      console.error('Failed to save voice settings:', error);
    }
  }, [speech.voiceRate, speech.voicePitch, speech.voiceVolume, continuousListening]);
  
  // Save conversation history when it changes
  useEffect(() => {
    try {
      const historyWithConvertedMessages = conversationHistory.map(convo => ({
        ...convo,
        messages: convertToLegacyMessageFormat(
          // @ts-ignore - we're handling the conversion between message formats
          convo.messages
        )
      }));
      
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(historyWithConvertedMessages));
    } catch (error) {
      console.error('Failed to save conversation history:', error);
    }
  }, [conversationHistory]);
  
  // Setup keyboard shortcuts
  useEffect(() => {
    if (!isOpen) return;
    
    const handleKeyDown = (e: KeyboardEvent) => {
      // Space to toggle listening (but not if we're typing in the input field)
      if (e.code === 'Space' && document.activeElement !== inputRef.current) {
        e.preventDefault();
        recognition.toggleListening();
      }
      
      // Escape to close the chat
      if (e.code === 'Escape') {
        toggleChat();
      }
      
      // Ctrl + / to toggle settings
      if (e.code === 'Slash' && e.ctrlKey) {
        e.preventDefault();
        setShowSettings(prev => !prev);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, recognition.isListening]);

  const sendMessage = async (messageText: string) => {
    if (!messageText.trim()) return;
    
    // Create a new message
    const userMessage: Message = {
      id: generateId(),
      role: 'user',
      content: messageText,
    };
    
    // Update the messages array
    setMessages(prevMessages => [...prevMessages, userMessage]);
    
    // Analyze user message for shopping intent
    analyzeUserMessage(
      messageText, 
      shopping.setShoppingFlowState, 
      shopping.setLastCategory, 
      shopping.shoppingFlowState
    );
    
    // Clear the input
    setInput('');
    
    try {
      setLoading(true);
      
      // Check if the user is asking about products not offered by e-com
      const nonEcomProductQuery = checkForNonEcomProducts(messageText);
      if (nonEcomProductQuery) {
        // Create a canned response explaining store limitations
        const assistantMessage: Message = {
          id: generateId(),
          role: 'assistant',
          content: `I'm sorry, but e-com currently only offers products in these categories: phones, laptops, accessories, furniture, shoes, and clothes. We don't currently carry ${nonEcomProductQuery}. Is there something from our available categories I can help you find?`,
          timestamp: new Date()
        };
        
        setMessages(prevMessages => [...prevMessages, assistantMessage]);
        speech.speak(assistantMessage.content);
        setLoading(false);
        return;
      }
      
      // Send the message to the API
      const response = await api.chatWithToolCalls(messageText);
      
      if (!response.success) {
        throw new Error(response.error || 'Network response was not ok');
      }
      
      // Extract the response data
      const message = response.message || response.data?.reply || '';
      const toolCalls = response.data?.toolCalls || [];
      
      // Add the assistant's response to the messages
      const assistantMessage: Message = {
        id: generateId(),
        role: 'assistant',
        content: message,
        toolCalls: toolCalls.length > 0 ? toolCalls : undefined
      };
      
      setMessages(prevMessages => [...prevMessages, assistantMessage]);
      
      // Process tool calls if present
      if (toolCalls && toolCalls.length > 0) {
        await shopping.handleToolCalls(toolCalls);
      } 
      
      // Update state based on message content if there's a message
      if (message) {
        updateStateFromAssistantMessage(
          message, 
          shopping.setShoppingFlowState, 
          shopping.setLastCategory, 
          shopping.shoppingFlowState
        );
        
        speech.speak(message);
      } else if (toolCalls.length === 0) {
        // Only show error if there's no message AND no tool calls
        console.error('Empty response from API', response);
        const fallbackMessage: Message = {
          id: generateId(),
          role: 'assistant',
          content: 'I apologize, but I seem to be having trouble right now. Please try again or contact support if the issue persists.',
        };
        
        setMessages(prevMessages => [...prevMessages, fallbackMessage]);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      
      // Add an error message
      const errorMessage: Message = {
        id: generateId(),
        role: 'assistant',
        content: 'I apologize, but I encountered an error while processing your request. Please try again later.',
      };
      
      setMessages(prevMessages => [...prevMessages, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (input.trim()) {
        sendMessage(input);
      }
    }
  };

  const toggleChat = () => {
    setIsOpen(prev => !prev);
    if (!isOpen) {
      // Close any open panels
      setShowSettings(false);
      setShowHistory(false);
      
      // Start a new conversation
      setActiveConversationId(null);
      
      // Send welcome message when chat is opened
      const welcomeMessage = "Welcome to e-com! I'm your AI shopping assistant.";
      const storeInfo = "I can help you browse phones, laptops, accessories, furniture, shoes, and clothes.";
      const voiceTip = recognition.isSupported ? 
        "Click the microphone button or press Space to speak, or type your questions." : 
        "Type your questions and I'll help you find what you need.";
      
      setMessages([{ 
        id: generateId(),
        role: 'assistant', 
        content: `${welcomeMessage} ${storeInfo} ${voiceTip} How can I help you today?`,
        timestamp: new Date()
      }]);
      
      // Speak the welcome message
      speech.speak(`${welcomeMessage} ${storeInfo} ${voiceTip} How can I help you today?`);
    } else {
      // Stop any ongoing speech when closing
      window.speechSynthesis.cancel();
      
      // Stop listening if active
      if (recognition.isListening) {
        recognition.stopListening();
      }
    }
  };
  
  const startNewConversation = () => {
    // Clear current messages
    setMessages([{ 
      id: generateId(),
      role: 'assistant', 
      content: "Welcome back to e-com! I'm ready to help you find phones, laptops, accessories, furniture, shoes, or clothes. What are you looking for today?",
      timestamp: new Date()
    }]);
    
    // Reset active conversation
    setActiveConversationId(null);
    
    // Close history panel
    setShowHistory(false);
  };
  
  const loadConversation = (conversation: ConversationHistoryItem) => {
    // Convert legacy format messages to new format
    const newFormatMessages = conversation.messages.map(msg => ({
      id: msg.id,
      role: msg.sender === 'user' ? 'user' as const : 'assistant' as const,
      content: msg.text,
      timestamp: msg.timestamp,
      toolCalls: msg.toolCalls
    }));
    
    setMessages(newFormatMessages);
    setActiveConversationId(conversation.id);
    setShowHistory(false);
    
    // Reset the shopping panel
    shopping.setPanelView('products');
    shopping.setIsCheckoutMode(false);
  };
  
  const deleteConversation = (id: string) => {
    setConversationHistory(prev => prev.filter(conv => conv.id !== id));
    
    // If we deleted the active conversation, start a new one
    if (id === activeConversationId) {
      startNewConversation();
    }
  };
  
  const clearAllHistory = () => {
    if (window.confirm('Are you sure you want to delete all conversation history?')) {
      setConversationHistory([]);
      startNewConversation();
    }
  };

  // Create voice visualization bars
  const renderVoiceVisualization = () => {
    if (!recognition.isListening || recognition.visualizerData.length === 0) {
      return null;
    }
    
    return (
      <div className="voice-visualization">
        {recognition.visualizerData.map((value, index) => (
          <div 
            key={index} 
            className="voice-bar" 
            style={{ height: `${Math.max(5, value * 40)}px` }}
          />
        ))}
      </div>
    );
  };

  return (
    <>
      {/* Chat toggle button */}
      {!isOpen && (
        <button 
          onClick={toggleChat}
          className="chat-toggle-button"
          aria-label="Open e-com shopping assistant"
        >
          <div className="toggle-icon-container">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="chat-icon">
              <path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" />
            </svg>
          </div>
          <span className="toggle-label">e-com Assistant</span>
        </button>
      )}

      {/* Voice Chat container */}
      {isOpen && (
        <div className="voice-chat-container">
          {/* Chat panel */}
          <div className="chat-panel">
            <div className="chat-header">
              <h2>AI Shopping Assistant</h2>
              <div className="chat-controls">
                <button onClick={() => recognition.toggleListening()} className="mic-button">
                  {recognition.isListening ? 'Stop' : 'Start'} Listening
                </button>
                <button onClick={() => setShowSettings(true)} className="settings-button">Settings</button>
                <button onClick={() => setShowHistory(true)} className="history-button">History</button>
                <button onClick={toggleChat} className="close-button">Close</button>
              </div>
            </div>
            
            <div className="chat-window">
              {messages.map((message) => (
                <div 
                  key={message.id} 
                  className={`message ${message.role === 'user' ? 'user-message' : 'assistant-message'}`}
                >
                  <div className="message-content">{message.content}</div>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </div>
            
            {showBrowserNotice && (
              <div className="browser-notice">
                {recognition.browserCompatWarning}
              </div>
            )}
            
            {renderVoiceVisualization()}
            
            <div className="chat-input">
              <input
                ref={inputRef}
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Type a message..."
                disabled={loading}
              />
              <button 
                onClick={() => sendMessage(input)}
                disabled={!input.trim() || loading}
                className="send-button"
              >
                Send
              </button>
              <button
                onClick={() => recognition.toggleListening()}
                className={`mic-button ${recognition.isListening ? 'active' : ''}`}
                disabled={!recognition.isSupported || shopping.isCheckoutMode}
              >
                {recognition.isListening ? 'Stop' : 'Start'} Listening
              </button>
            </div>
            
            {recognition.isListening && (
              <div className="listening-indicator">
                Listening...
              </div>
            )}
            
            {speech.isSpeaking && (
              <div className="speaking-indicator">
                Speaking...
              </div>
            )}
            
            {showSettings && (
              <VoiceSettingsPanel
                voiceRate={speech.voiceRate}
                voicePitch={speech.voicePitch}
                voiceVolume={speech.voiceVolume}
                continuousListening={continuousListening}
                selectedVoice={speech.selectedVoice}
                availableVoices={speech.availableVoices}
                onRateChange={speech.setVoiceRate}
                onPitchChange={speech.setVoicePitch}
                onVolumeChange={speech.setVoiceVolume}
                onVoiceChange={speech.setSelectedVoice}
                onContinuousListeningChange={setContinuousListening}
                onClose={() => setShowSettings(false)}
              />
            )}
            
            {showHistory && (
              <ConversationHistory
                history={conversationHistory}
                activeConversationId={activeConversationId}
                onSelectConversation={loadConversation}
                onDeleteConversation={deleteConversation}
                onClearAllHistory={clearAllHistory}
                onClose={() => setShowHistory(false)}
              />
            )}
          </div>
          
          {/* Shopping panel */}
          <div className="shopping-panel">
            <ShoppingPanel 
              view={shopping.panelView}
              searchQuery={shopping.searchQuery}
              productId={shopping.selectedProductId}
              onCheckoutComplete={shopping.exitCheckoutMode}
              shoppingFlowState={shopping.shoppingFlowState}
              lastCategory={shopping.lastCategory}
            />
          </div>
        </div>
      )}
    </>
  );
};

export default VoiceChatBot;
