import express from 'express';
import fs from 'fs';
import path from 'path';
import db from '../models/index.js';

const router = express.Router();

// Helper: safe write file ensuring directory exists
function writeFileSafe(filePath, content) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(filePath, content, 'utf8');
}

// GET session memory: last N messages
router.get('/session/:sessionId/memory', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const limit = Number(req.query.limit || 30);
    const session = await db.ChatSession.findOne({ where: { session_id: sessionId } });
    if (!session) return res.json({ success: true, data: [] });
    const messages = await db.ChatMessage.findAll({
      where: { session_id_fk: session.id },
      order: [['createdAt', 'ASC']],
      limit,
    });
    return res.json({ success: true, data: messages });
  } catch (e) {
    console.error('memory get error', e);
    return res.status(500).json({ success: false, error: 'Failed to fetch memory' });
  }
});

// POST upsert a memory message
router.post('/session/:sessionId/memory', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { role, content, tool_calls } = req.body || {};
    if (!role || !content) return res.status(400).json({ success: false, error: 'role and content are required' });
    const session = await db.ChatSession.findOrCreate({ where: { session_id: sessionId }, defaults: { session_id: sessionId } }).then(([s]) => s);
    const msg = await db.ChatMessage.create({ session_id_fk: session.id, role, content, tool_calls: tool_calls || null });
    return res.json({ success: true, data: msg });
  } catch (e) {
    console.error('memory post error', e);
    return res.status(500).json({ success: false, error: 'Failed to store memory' });
  }
});

// POST raw SQL read-only query (safe: only SELECT allowed)
router.post('/db/query', async (req, res) => {
  try {
    const { sql, replacements } = req.body || {};
    if (!sql || !/^\s*select/i.test(sql)) return res.status(400).json({ success: false, error: 'Only SELECT queries allowed' });
    const rows = await db.sequelize.query(sql, { replacements, type: db.Sequelize.QueryTypes.SELECT });
    return res.json({ success: true, data: rows });
  } catch (e) {
    console.error('db query error', e);
    return res.status(500).json({ success: false, error: 'Query failed' });
  }
});

// POST DB update via limited table/columns whitelist
router.post('/db/update', async (req, res) => {
  try {
    const { table, where, values } = req.body || {};
    const whitelist = {
      Products: ['price', 'description', 'images', 'attributes'],
      Inventories: ['stock_quantity', 'restock_date'],
      Users: ['preferences'],
    };
    if (!whitelist[table]) return res.status(400).json({ success: false, error: 'Table not allowed' });
    const allowed = Object.fromEntries(Object.entries(values || {}).filter(([k]) => whitelist[table].includes(k)));
    if (Object.keys(allowed).length === 0) return res.status(400).json({ success: false, error: 'No allowed fields to update' });
    const [count] = await db.sequelize.getQueryInterface().bulkUpdate(table, allowed, where || {});
    return res.json({ success: true, data: { updated: count } });
  } catch (e) {
    console.error('db update error', e);
    return res.status(500).json({ success: false, error: 'Update failed' });
  }
});

// POST create a new frontend page component and register entry in a manifest for dynamic routing
router.post('/pages', async (req, res) => {
  try {
    const { routePath, title = 'AI Page', componentCode } = req.body || {};
    if (!routePath) return res.status(400).json({ success: false, error: 'routePath is required' });
    const pagesDir = path.join(process.cwd(), '..', 'frontend', 'src', 'ai-pages');
    const manifestPath = path.join(pagesDir, 'manifest.json');
    const safeName = routePath.replace(/[^a-z0-9/_-]/gi, '').replace(/\/+/, '/').replace(/^\//, '').replace(/\//g, '_') || 'page';
    const fileName = `${safeName}.tsx`;
    const filePath = path.join(pagesDir, fileName);

    const defaultCode = componentCode || `import React from 'react';
export default function AIGeneratedPage(){
  return (<div className="app-container"><h1>${title}</h1><p>This page was generated by AI.</p></div>);
}`;

    writeFileSafe(filePath, defaultCode);

    // Update manifest
    let manifest = [];
    if (fs.existsSync(manifestPath)) {
      try { manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8') || '[]'); } catch {}
    }
    // De-duplicate
    manifest = manifest.filter(p => p.routePath !== routePath);
    manifest.push({ routePath, file: fileName, title });
    writeFileSafe(manifestPath, JSON.stringify(manifest, null, 2));

    return res.json({ success: true, data: { routePath, file: fileName } });
  } catch (e) {
    console.error('create page error', e);
    return res.status(500).json({ success: false, error: 'Failed to create page' });
  }
});

// GET manifest for frontend dynamic routes (served from source dir)
router.get('/pages/manifest', async (_req, res) => {
  try {
    const manifestPath = path.join(process.cwd(), '..', 'frontend', 'src', 'ai-pages', 'manifest.json');
    if (!fs.existsSync(manifestPath)) return res.json({ success: true, data: [] });
    const json = JSON.parse(fs.readFileSync(manifestPath, 'utf8') || '[]');
    return res.json({ success: true, data: json });
  } catch (e) {
    console.error('get manifest error', e);
    return res.status(500).json({ success: false, error: 'Failed to load manifest' });
  }
});

// Routes index and DB schema for AI awareness
router.get('/introspect', async (_req, res) => {
  try {
    // Basic route map (static list)
    const routes = [
      '/api/products',
      '/api/products/search',
      '/api/categories',
      '/api/cart',
      '/api/checkout',
      '/api/reviews',
      '/api/orders',
      '/api/admin',
      '/api/assist',
      '/api/ai/pages',
      '/api/ai/pages/manifest',
      '/api/ai/db/query',
      '/api/ai/db/update',
      '/api/ai/session/:id/memory'
    ];

    // DB schema: list tables and columns from Sequelize models
    const schema = Object.entries(db.sequelize.models).map(([name, model]) => {
      const attributes = Object.entries(model.rawAttributes || {}).map(([col, def]) => ({
        name: col,
        type: def.type?.toString?.() || String(def.type || ''),
        allowNull: def.allowNull !== false,
        primaryKey: !!def.primaryKey,
      }));
      return { name, tableName: model.getTableName?.() || name, attributes };
    });

    // List all categories for easier product search
    const categories = await db.Category.findAll({
      attributes: ['id', 'name', 'description']
    }).catch(() => []);

    // Get product counts by category
    const categoryCounts = [];
    if (categories.length > 0) {
      for (const cat of categories) {
        const count = await db.sequelize.query(
          `SELECT COUNT(*) FROM "ProductCategories" WHERE "category_id" = ?`,
          { 
            replacements: [cat.id],
            type: db.Sequelize.QueryTypes.SELECT 
          }
        ).then(res => res[0]?.count || 0).catch(() => 0);
        
        categoryCounts.push({
          id: cat.id,
          name: cat.name,
          productCount: parseInt(count)
        });
      }
    }

    return res.json({ 
      success: true, 
      data: { 
        routes, 
        schema, 
        categories, 
        categoryCounts 
      } 
    });
  } catch (e) {
    console.error('introspect error', e);
    return res.status(500).json({ success: false, error: 'Failed to introspect' });
  }
});

// Safe FS read endpoints: only allow certain directories
const allowedDirs = [
  path.join(process.cwd(), '..', 'frontend', 'public'),
  path.join(process.cwd(), '..', 'backend', 'uploads'),
];

router.get('/fs/list', (req, res) => {
  try {
    const dir = req.query.dir ? String(req.query.dir) : allowedDirs[0];
    if (!allowedDirs.some(p => dir.startsWith(p))) return res.status(403).json({ success: false, error: 'Forbidden' });
    const items = fs.readdirSync(dir).map(name => ({ name, isDir: fs.statSync(path.join(dir, name)).isDirectory() }));
    return res.json({ success: true, data: items });
  } catch (e) {
    return res.status(500).json({ success: false, error: 'Failed to list directory' });
  }
});

router.get('/fs/read', (req, res) => {
  try {
    const file = String(req.query.file || '');
    if (!allowedDirs.some(p => file.startsWith(p))) return res.status(403).json({ success: false, error: 'Forbidden' });
    if (!fs.existsSync(file) || fs.statSync(file).isDirectory()) return res.status(400).json({ success: false, error: 'Invalid file' });
    const content = fs.readFileSync(file, 'utf8');
    return res.json({ success: true, data: { file, content } });
  } catch (e) {
    return res.status(500).json({ success: false, error: 'Failed to read file' });
  }
});

export default router;
